= Statechart Routing Design
:author: Tony Kay
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 3
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: /assets/img
:scriptsdir: js
:imagesoutdir: docs/assets/img
:favicon: docs/assets/favicon.ico

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

= General Requirements/Goals

* The user/programmer should be able to express arbitrary movement.
* Systems should be composable as much as possible: Sub-charts with routes, invocations with routes.
* Some level of URL integration should be possible for browser usage, but sane limitations should apply to reduce complexity.
** Complete arbitrary composition of statecharts leads to scenarios where URL representation is quite difficult or even insane.
*** IS possible to "fix" this problem with the user coding explcit top-level transitions that resolve conflicts. E.g. auto-detect when there is ambiguity that is not resolved by a manual top-level transition.
* "Current" route can somehow deny movement (unsaved changes)
* Minimal logic in UI. Very statechart centric.

== Challenges

Invocations involve multiple running charts which have a structural relation to the "root" or "parent" chart, but the active instance of the chart (and its definition) are *external* by definition. This means that structural navigation of the statechart hits a natural visibility boundary at any invocation. Of course this can be resolved because we can look up the invoked chart and continue structural navigation.


* Statechart invocations that have "routes".
** Should we structurally navigate across this composition for URL integration?
*** Is it reasonable to leave it out, or is this likely to be a major way large applications are structured?
** Probably should NOT accept state children on an invocation route, because then we cannot structurally navigate routing across the invocation boundary. NOT sure that even makes sense.
** Composition across chart boundaries
* "External" routing events (bookmarks, user triggered popstate events)


= Operation

== Initialization

Putting a new thing on screen in Fulcro means you have to consider the data that will be displayed by that component. There are two basic categories: components that have well-known local starting data (which may or may not need to be reset on re-entry) and components whose data is derived in some (possibly async) way (i.e. loading).

The routing system's job is to manage the dynamic query of some container component (declared on the statechart), the query join (current data route) of that component,
and the job would not be complete without placing a proper ident at that same join point in application state (one could also argue that one could leverage alternative things like React hooks for UI composition, but that doesn't change much).

The lifecycle of a target therefore must at a minimum include a way to put data into the state database.

We could leave this completely up to the hand-written elements of your chart, simply by supporting an event that allows a route target to change their target ident. Such support is always required (the child might be a form that edits different instances of the same entity, where the ident changes as you move from entity to entity).

Such an event would be sufficient to handle all kinds of cases, but it misses one critical one: as the route is entered, the UI will try to render *something* and over time we may or may not have a pre-existing (from a prior entry) link there.

Even then, technically, as long as the state chart does *some* kind of synchronous state manipulation in entry handlers, the chart author can ensure things will be exactly as they desire.

So, the question becomes: is there some portion of this that needed by almost all routes, is trivial to implement consistently, and prevents some minor hassles or bugs that the user would have to defensively work against.

=== The Argument for Zero Help

Statecharts have on-entry and on-exit. They can easily be coded to handle exactly what is needed for any route simply by including the proper logic. The invocation support even lets that complete sub-chart be co-designed (and co-located) with an individual component.

The user can easily write their own "helper" chart elements that pre-combine things of arbitrary complexity (much like the rstate nodes do in this ns). So, repeated kinds of cases can pretty easily be pre-coded and re-used.

Designing a generic initialization system for all possible use-cases is therefore overreach.


=== The Argument for Routing-Centric Built-ins

Supplying a set of configuration options on the component (as RAD does) provides a great way to handle a lot of common cases. Unfortunately, real-world cases get complex quickly (cancelling routes, async behaviors, timing, etc.). Initialization is just one part of that, but it's kind of integral.

Simple initialization cases do exist though:

* Putting data in state for a component that has `:initial-state` and a constant `:ident`. This is what would have normally happened during app startup, but doesn't because of the lack of need to do query composition at route container nodes.
* Putting data in state that can be computationally generated synchronously. E.g. creating a new tempid, and merging that data to the app state.

Providing this minimum level of integration gets the base target into app state with existing mechanisms, assuming it can be done computationally.

One additional element that is trivial to implement and would be useful is having an option that specifies *when* this initialization happens:

* never - for cases where you handle it yourself
* once - for cases where it just has to happen once as it would in normal operation
* always - re-initialize it every time it becomes a new route

Other cases could be supported with "never" and custom chart elements.

The basic implementation is as follows:

* ro/initialize - An option to say :never, :once, :always
* ro/initial-props - A `(fn [env data ...])` with a statechart call signature that can generate the inital tree to be merged. The default for this calls `(get-initial-state TargetClass event-data)`.

The initialization routine can merge the resulting tree, and use `(get-ident TargetClass data)` to get the necessary ident for putting in the parent entity join location.

This covers the trivially useful (synchronous) cases.


=== Component Centric Possibilities

In an effort to be somewhat complete, we'll consider if there are additional cases that deserve special built-in treatment at the routing layer.

Fulcro leverages component-centric normalization, loading, and initialization in general. As such, it makes sense to consider how the lifecycle of components will interact with the ideas in UI routing: where you are choosing something to render from some UI context.

Arguments against further support include:

* It violates the single-responsibility principle. Routing is about choosing a thing to show, not implementing the intricasies of I/O and interaction.
* The act of asynchronous interaction with components is inherently complex in arbitrary ways: route cancellation, load aborts, user feedback on slow interaction, etc.

Arguments *for* further support:

* You very commonly want:
** Self-aborting loads
** User feedback when routing is slow for some reason
** The ability for the user to attempt an abort.
** Centralization of these kinds of concerns so you don't pepper bugs all over the app

But, I would note that these kinds of standardizations can be written as supporting element types that can simply be embedded in your chart. For example a node that comprises the elements for starting and tracking a load, with the elements of timing and abort via states, entry/exit, and delayed events.

The whole point of developing this system is to move as much logic as possible into charts.

So, there is a good argument for providing at least some example reusable "subcharts" that combine these elements together in a nice reusable way.

== Route Denial/Control

Route denial is a tough one. Chaging the route is something a user can trigger globally in many ways (back button, click link) and some UI elements want to prevent the user from losing unsaved changes.

Having a "default" way to handle this is a great user convenience, but it can get rapidly complex when you consider things like "how and where do I show a message?", and "how do I allow a set of subroutes, but deny others".

Again, the most general solution is to code it all in the chart, but there are some patterns we could pre-define to save the user some work.

=== Component Centric

One way to implement this is to put expressions on the individual target components

[source]
-----
(defsc Route [this props]
  {ro/busy? (fn [& args] true/false) ...
-----

and then when a routing command is issued, we ask the active routes (found via the current configuration and the statechart definition) if any of them are busy, and use a single catch-all transition at the top of the chart with a cond:

[source]
-----
(transition {:event :route-to.*
             :cond any-active-target-busy?
             :target :state/show-route-denied})
-----

A high-level parallel node houses a "route denied machine" that tracks when we should show a message (which the show-route-denied event moves to).

This allows the "modal" nature of a "unsaved changes" message to be supported in a global way, and the helpers can save the attempted route for override (e.g. yes, route anyway).

Pros:

* Compositional logic
* Local components declare local logic to indicate route denial
* One top-level state for handling the messaging to the user

Cons:

* What does the busy handler get as args?
* Not statechart-centric...pushes logic to component (cond isn't visible in the chart)
* Traceability...who denied the route???
* The definition of the "route denied" region in the parallel state might need to be more complex (e.g. is it a modal, or a toast that fades? Do we allow them to double-click a route to go anyway? Etc.). Letting the user replace it would be a necessity. Is that easy to document/explain/plug in?

=== Statechart Centric

Instead of (or possibly in addition to?) the above, this can easily be coded AS a catch-all transition in the state that might deny routes itself.

Statechart transition semantics indicate that in a duplicate transition match the deepest one wins. So we can acutally *have* the global handling *and* a chart-centric handling of these cases.

[source]
-----
(transition {:event :route-to.*})
(uir/rstate {:id :route/a}
    (rstate {:route/target `X}) ; form wizard page 1
    (rstate {:route/target `Y}) ; form wizard page 2
    (rstate {:route/target `Z}) ; form wizard page 3
    (transition {:event :route-to.X.* :target `X}) ; unconditional local routing
    (transition {:event :route-to.Y.* :target `Y})
    (transition {:event :route-to.Z.* :target `Z})
    (transition {:event :route-to.* ; disallow global routing
                 :cond (is-form-state-dirty-predicate :form.actor/name)
                 :target :state/local-state-handling-denial}
       (script {:src (fn [] [(assign :show-warning? true)])})))
-----

It seems like this is compatible with the prior solution, so providing both is trivial, and it is also trivial for the user to write their own wrapper function to make this succinct:

[source]
-----
(on-route I-am-busy? [(fop/assoc-alias :ui/busy? true)])
-----

==== Predicate Expressions

It is important to note that an event doesn't, per se, contain information about where in the statechart it was delivered; so, helper functions (or closures) would need to be used to determine those details.

You could also do this introspection at evaluation (of the chart) if you design a top-down syntactic notation for the overall grouping. E.g. options on an `rstate` node.

[source]
-----
(rstate {:busy-predicate is-form-dirty? ...})
-----

which expands to the transition node, but includes details about the parent in an extra arg as a partial over the predicate. `(partial is-form-dirty? RouteA21)`.

== Composition

== URL Integration

=== Requirements

* Statechart is single-source of truth for URL
** Popstate events are properly handled and the history morphed to reflect reality
* The URL is an unambiguous representation of a single `:route-to.target/Thing` event, for which there is a top-level transition.
* The mappings between states and URL can be composed with annotations on the states in the model.
** Shorter URL paths can represent the "entry point" into an entire subchart, which of course will make substates active automatically.
*** Such Automatically activated states with URL elements must synchronize with the URL after statechart stabilization. The sub-sequence of URL transitions while a statechart is internally processing (e.g. flowing through states and substates that contribute to the URL), along with the original user input URL, need not be preserved (e.g. intermediate URLs are replaced instead of pushed). Only the final stable URL is preserved (back button nav wouldn't work if it hits these intermediate states).
* Live on-screen components can contribute to the URL parameters (e.g. report search criteria, current page, selected row, etc.)
** This parameter integration MUST allow for ui-driven events that indicate a change (since those UI interactions may not involve the statechart system).
** The parameter list of the URL SHOULD be derivable from the complete statechart AND application state, or the ability of the URL integration will not be able to properly rewrite the URL (unless it only rewrites the path)?

=== Browser URL Notes

The history API of browsers is not exactly ideal, because in that API the concept of forward/back navigation is hidden behind a single "popstate" event which simply hands you the one element (of a non-visible stack of states) that you are supposed to display. This means that you don't get a "forward" or "back" event, but it isn't that hard to implement what we need.

For any given *external* routing event (user changes the URL via bookmark, page load, forward, or back button, or we call the js forward()/back() API) we have:

* The js state that we stored (if it is a forward/back), or no state if it is an initial load of the URL (browser specific on what we get in this initial event). From the MDN docs:
"Browsers tend to handle the popstate event differently on page load. Chrome (prior to v34) and Safari always emit a popstate event on page load, but Firefox doesn't."

There is *no way* to block user forward/back. It is up to our implementation to deduce this action and handle it.

The browser interface to history is meant for you to store js "state" with history entries that tell you unambiguously where you are. In a complex application where statecharts may make decisions that invalidate some prior stored state (e.g. a particular URL runs a side effect that could move you to a different state) it makes no sense to try to treat this state as a functional-programming immutable value. The assumptions of the API are that your URL refers to some bit of data that you have fetched and are possibly caching.

In an SPA, the URL is "roughly" stating a desire to be in some particular portion of a complex application, but the state of that subsection is nondeterministic, and the URL is at-best a hand-waving motion "go over there".

So, let's restate what the URL browser history supplies to us in terms of (statechart-specific) semantic importance:

Events from the actions of a user:

* A desire to move the chart into some particular configuration (we target a particular state, and other states in the configuration follow as a natural course of the chart's design). E.g. user uses a bookmark to load the application.
* An popstate event from the browser to "go backward" or "go forward"

Actions produced by the internals of the application that affect the URL/history:

* Add something to history (pushState).
* Rewrite the current URL (replaceState).
* Internal desire to move forward/back in an abstract sense.

The forward/back actions could be internal or external. In the internal case there is nothing to undo, but in the external there is (the browser manipulated the URL).

The natural join point of these concerns is in the external event queue handler, since the statechart will do nothing without an event from there (even timed events come into that queue.)

[source]
-----
(defn process-event! [external-event]
   (do-statechart-actions! external-event)
   (notify-url-integration!))
-----

==== Popstate Facade

In order to convert popstate events into our desired semantics, we propose this approach:

* The act of changing the URL from internals is expressed either as a push or replace (as normal)
** Our implementation of history keeps track of a sequence number:
*** On push, incrememt
*** On replace, do nothing
*** On popstate *success* (not undo), reset sequence number to what was received.
** The sequence number is always stored as the `state`

When we receive a popstate event, look at the current sequence number:

* If it went up, it was an external forward
* If it went down, it was an external back

Send the proper event, wait for stabilization, and then:

* On undo: call history forward() or back() in the opposite direction.
* Otherwise: Reset current sequence number to what we popped.

This allows us to sense the semantic action and have the statechart act on it, and the URL is usable mainly for bookmark support and validation for "undo".

===== Tricky Cases

Case 1:

The user presses back, the statechart changes, the detection fails, and we issue an "undo" (forward).

Actual Result: In this case we lose the "forward" action because the browser has been asked (by undo) to reverse it already. The final "synchronization" of the URL will use replaceState to fix the URL to match the resulting state (perhaps only the params changed), but this violates the user's expectation of being able to reverse a navigation action. This is a minor annoyance and should be rare.

Case 2:

External timed events happen which are *not* explicit routing events, but URL synchronization is built to happen after each chart stabilization. This could pollute the history with a huge number of "useless" states.

Resolution: The automatic URL synchronization should always use replaceState, so that we are not accumulating history.

Case 3:

Semantic use of forward/back is desired, but it doesn't track in the path portion of the URL (e.g. changes URL parameter page=2 to page=3). We want history entries. The history entry in question cannot be restored via a bookmark (e.g. jumping to wizard page 3 makes no sense from a bookmark).

Resolution: In the actual chart, tracking the page as a parameter can be automated, and the forward/back events can be handled while in the substates. The URL should end up matching, preventing "undo" events. A bookmark will enter the system, and establish the upper-level state, but of course the substates won't be willing to interpret the page number, and will instead enter at page 1. When the statechart stabilizes the URL is seamlessly replaced with the parameter reset to `page=1`.

NOTE: The page parameter CAN be leveraged by the statechart, so if it were possible to jump to page 3, then eventless transitions on the target node could include a condition that interprets the parameter and does the right thing. Page is probably a bad example because you certainly would not typically have states for an arbtrarily large number of pages, but for a wizard with 3 pages a set of 3 states with 3 transitions isn't overly complicated. So, there are two kinds of cases: the parameter is truly just data used by an ultimate target state (which page is this ONE state showing), and the other is where the parameter is attempting to disambiguate a particular statechart configuration that a single path in a URL cannot represent.

=== URL Parameters

Changing (trackable) states in the statechart will affect the PATH component of the URL. All other internal tracking will use the query section of the URL, since those elements are not *required* to be something that can be restored; however, there are at least two categories of URL parameters: Those used by the statechart for structural reasons (e.g. which page of a wizard), and parameters that are used by the application's internal functionality (which page of a report am I on, which row is selected, what date range did the user pick).

The first of these two (structural parameters) can be encoded on the chart itself.

The second of these two represents either:

* Information stored only on the URL for bookmarking purposes.
* A reflection of internal data from components.

In Fulcro we will mostly that the latter is what we want, since we don't want to *rely* on a URL (which is only available in a browser) to store interesting state.

The question becomes: How do we allow our URL support mechanism to derive this "extra" information during the final phase (post-stabilization generation of the current URL)?

In RAD, for example, parameters are stored in two primary locations: on the active component (e.g. Report instance state), or in a normalized table of parameters that have globally unique names. In Fulcro in general these are really the only two options: The data you care about is in some constant (global) location, or it is co-located with the normalized component that cares about it at some particular sub-path(s).

The main routing system *does* track the ident of the route targets:

* If the component uses the initialization system, the ident is saved into the local data of the chart.
* If it doesn't we can assume the target has a constant ident and it was pre-normalized for us.

In either case for unambiguous targets, we know where to find their state in the Fulcro state map. And of course, global locations in the state map are just that: global.

However, it is possible that some substates in a chart might want to store particular data (derived from app state) in the URL. If the routing system has explicit knowledge of their ident (they are an rstate), then we can find them, but if they are active states related to on-screen components how do we find the location of the data in order to include it?

=== Crossing Invocations

Deriving the "current URL" involes starting at the overall root UI Routing session:

* Determine which of the states in the active config contribute to the PATH ()
* Determine if any of them have active child invocations

==== Invocation Dependencies

What if a nested invocation requires data from a parent context, and that parent context resolves that data via on-entry handlers that are async?

In fact, how do we deal with routing asynchrony in general? If a sub-route somehow relies on setup that is done by some parent node in the chart, but that setup is async. The chart will enter all the states at once.

NOTE: working on the real structure which requires each node to pass the "remainder" route to child...so we cascade through the routing, and when it terminates, THAT is when we update the final URL and consider "routing done". We need to be able to interrupt this, of course (aborting loads, etc.).


=== Implementation Notes

Our desire to have routes that indicate they are busy and block routing means we need a way to "undo" a particular user action. We can do this by calling the forward() or back() method (in the opposite diretion of the user) if we can detect the direction of their navigation, but this generates additional PopStateEvents.

Any given routing request from the browser (forward/back) comes with a URL. Our requirement that we can find a 1-to-1 mapping from a URL to a desired event means that we can unambiguously determine the desired location, but without analyzing the chart (or having a stateful "fact" that says "routing blocked") there is no way for an externally-written system to automatically "deny" (and undo) routing.

So, the important points are:

* External events (forward/back) MIGHT need to be immediately reversed (cannot be blocked).
* The statechart should be the arbiter or URL correctness
* We want to preserve the ability of a user to go forward after a back, if possible (e.g. should not pushState after a back in order to undo, but issuing the call to `forward()` also has to be evaluated to ensure the URL matches where the statechart lands). The assumption on an undo is that the statechart didn't move, so this validation should always prove correct except in the presence of bugs (e.g. the URL was already out of sync with the chart somehow).

The support we need:

* A function that can convert a URL into an unambiguous target state.
* A function that can be called after the statechart stabilizes to replace the URL with the final resting place of the chart.
* Some kind of predicate that can determine if a chart was affected by a popstate event, so that user navigation can be undone to preserve the ability to go "forward" after a "back".

The most difficult part here the preservation of forward/back semantics. A chart can be defined with "stable" routing states, but within those states might be substates that leverage things like URL parameters to establish specifics. For example, a wizard nested in a parallel region won't *have* an unambiguous route to cover all possible combinations via a path, but it could leverage the query params to store information that allows re-establishing something like "which page" the wizard was on. These could be stored in the history, and a popstate event might simply be asking to go back a page in the wizard. This would have no visible effect on the chart's "stable routing state" (the parent parallel node) but also would not be an explicit denial of routing.

The implementation, in general, is made much easier if the application can simply be asked "is routing currently blocked"? This would allow URL integration to immediately "undo" a user back/forward popstate event. Unfortunately, if we want to use transition composition to choose what is and is not blocked, this global mechanism doesn't really integrate well.

What if we convert the popstate event into an `:event/forward`, `:event/back`, or `:event/page-loaded`?

Then the statechart in question could leverage those as-is, and we can leave the manipulation of browser history up to the best-efforts of the URL integration component (e.g. it figures out the optimal thing to do: pushState, replaceState, back, forward).

In this scheme, basically the popstate event handler:

* Derives the statechart URL from the statechart as-is
* Sends the event with the URL.
** The default forward/back/page loaded handlers use the URL and just raise the appropriate route-to event.
* Waits for the statechart to stabilize (TBD).
* Derives the statechart URL from the statechart again, and compares it to the current URL
** If it didn't change, undo.
** Else use replaceState to synchronize the URL

==== Synchronization

For all of this to work correctly, the URL synchronization needs to happen consistently, but we have to be careful because the timing of the sync has to be sensitive to the above evaluation of external routing events.


=== Chart Ambiguity Resolution

[source]
-----
    ;; Any Parallel section MUST resolve ambiguity by
    ;; putting an explicit path on EXACTLY ONE child.
    (parallel {:id :state/p}
      (uir/rstate {:route/target `RouteA1
                   :id :state/a1
                   :initial      :route/a}
        ;; eventless transition can be used to re-establish substates here.
        (transition {:cond if-url-param-infers-other :target :other})
        (uir/rstate {:id :route/a})
        (uir/rstate {:id :other}
          (on-entry {} (script {:src remove-other-param-to-url})))
          (on-exit {} (script {:src remove-other-param-to-url}))))
      (uir/rstate {:route/target `RouteA2
                   :id :state/a2
                   :route/path   ["c"]}
        (uir/rstate {:id         :route/c
                     :route/path "A"})
        (uir/istate {:route/target     `RouteA21
                     :route/path       ["B"]
                     :exit-target      ::RouteA1
                     :child-session-id ::route-a21})
-----

The implementation of this is to generate top-level transitions for the composed path:

[source]
-----
["c" "A"] <-> #url "/c/A" <-> {:target :route/c}
-----

which unambiguously defines the subset configuration `#{:state/p :state/a1 :state/a3 :route/c}` as the *target* for an *incoming* URL "/c/A". Note that during operation the actual configuration subset that is guaranteed is #{:state/p :state/a2}. That does mean that the internal operation is *not necessarily* represented by the URL (which was the known problem). Further resolution could be done by the implementation (user level) parameters on the URL, with on-entry handlers.
